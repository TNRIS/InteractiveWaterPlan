// Generated by CoffeeScript 1.3.3

Ext.define('TNRIS.theme.ProposedReservoirsTheme', {
  extend: 'TNRIS.theme.InteractiveTheme',
  themeName: null,
  loadTheme: function() {
    var map;
    map = this.mapComp.map;
    this.mapComp.removePopupsFromMap();
    this.mapComp.clearVectorLayer();
    this.mapComp.removeFeatureControl();
    this.contentPanel.update("<h3>Proposed Reservoirs</h3>\n<p>Click on a reservoir to see the water user groups that will benefit from its supply.</p>");
    this.themeStore.load({
      params: {
        ThemeName: this.themeName
      },
      scope: this,
      callback: function(records, operation, success) {
        var layer, new_layers, new_lyr, rec, _i, _j, _len, _len1, _ref;
        new_layers = [];
        if (!success) {
          return false;
        }
        for (_i = 0, _len = records.length; _i < _len; _i++) {
          rec = records[_i];
          _ref = rec.data.Layers;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            layer = _ref[_j];
            if (layer.ServiceType === "WMS") {
              new_lyr = new OpenLayers.Layer.WMS(layer.Name, layer.Url, {
                layers: layer.WMSLayerNames,
                transparent: true
              });
              new_layers.push(new_lyr);
            }
          }
        }
        this.mapComp.addLayersToMap(new_layers);
        this.mapComp.setupFeatureControl(new_layers);
        return null;
      }
    });
    return null;
  },
  showFeatureResult: function(features, clickedPoint, year) {
    var map, res_feat, reservoir, wktFormat;
    map = this.mapComp.map;
    this.mapComp.removePopupsFromMap();
    this.mapComp.clearVectorLayer();
    this.mapComp.vectorLayer = new OpenLayers.Layer.Vector("Planned Reservoir User Entities", {
      styleMap: new OpenLayers.Style({
        pointRadius: 4,
        strokeColor: '${getStrokeColor}',
        strokeWidth: 0.5,
        fillColor: '${getColor}',
        fillOpacity: 0.8
      }, {
        context: {
          getColor: function(feature) {
            switch (feature.attributes['type']) {
              case 'reservoir':
                return 'blue';
              case 'entity':
                return 'green';
              case 'line':
                return 'grey';
            }
            return 'red';
          },
          getStrokeColor: function(feature) {
            switch (feature.attributes['type']) {
              case 'reservoir':
                return 'cyan';
              case 'entity':
                return 'lime';
              case 'line':
                return 'grey';
            }
            return 'red';
          }
        }
      })
    });
    reservoir = features[0];
    wktFormat = new OpenLayers.Format.WKT();
    res_feat = wktFormat.read(reservoir.WKTGeog);
    res_feat.geometry.transform(map.displayProjection, map.projection);
    res_feat.data = reservoir;
    res_feat.attributes['type'] = 'reservoir';
    delete res_feat.data['WKTGeog'];
    this.contentPanel.update("<h3>" + res_feat.data.Name + ": " + year + "</h3>");
    this.mapComp.vectorLayer.addFeatures(res_feat);
    this.dataStore.load({
      params: {
        Year: year,
        forReservoirId: reservoir['Id']
      },
      scope: this,
      callback: function(records, operation, success) {
        var bounds, clickedResPoint, data, line, new_feat, rec, relatedFeatures, res_feat_centroid, select, _i, _len;
        if (!(records != null) || records.length === 0) {
          return null;
        }
        bounds = null;
        relatedFeatures = [];
        for (_i = 0, _len = records.length; _i < _len; _i++) {
          rec = records[_i];
          data = rec.data;
          new_feat = wktFormat.read(rec.data.WKTGeog);
          new_feat.data = data;
          new_feat.attributes['type'] = 'entity';
          new_feat.geometry = new_feat.geometry.transform(map.displayProjection, map.projection);
          clickedResPoint = map.getLonLatFromPixel(clickedPoint);
          res_feat_centroid = res_feat.geometry.getCentroid();
          line = new OpenLayers.Feature.Vector(new OpenLayers.Geometry.LineString([new OpenLayers.Geometry.Point(res_feat_centroid.x, res_feat_centroid.y), new OpenLayers.Geometry.Point(new_feat.geometry.x, new_feat.geometry.y)]));
          line.attributes['type'] = 'line';
          relatedFeatures.push(line);
          if (!(bounds != null)) {
            bounds = new_feat.geometry.getBounds();
          } else {
            bounds.extend(new_feat.geometry.getBounds());
          }
          relatedFeatures.push(new_feat);
        }
        this.mapComp.vectorLayer.addFeatures(relatedFeatures);
        map.addLayer(this.mapComp.vectorLayer);
        select = new OpenLayers.Control.SelectFeature(this.mapComp.vectorLayer, {
          hover: false,
          onSelect: function(feature) {
            var point, popup, _ref;
            if (!feature.data.Name) {
              return false;
            }
            point = {};
            _ref = [feature.geometry.getCentroid().x, feature.geometry.getCentroid().y], point.lon = _ref[0], point.lat = _ref[1];
            popup = new OpenLayers.Popup.FramedCloud("featurepopup", point, null, "<h3>" + feature.data.Name + "</h3>\n\nRedundant Supply: " + feature.data.IsRedundantSupply, null, true, function() {
              select.unselect(feature);
              return null;
            });
            feature.popup = popup;
            map.addPopup(popup);
            return null;
          },
          onUnselect: function(feature) {
            if (feature.popup) {
              map.removePopup(feature.popup);
              feature.popup.destroy();
              feature.popup = null;
            }
            return null;
          }
        });
        map.addControl(select);
        this.mapComp.selectFeatureControlId = select.id;
        select.activate();
        return null;
      }
    });
    return null;
  }
});
