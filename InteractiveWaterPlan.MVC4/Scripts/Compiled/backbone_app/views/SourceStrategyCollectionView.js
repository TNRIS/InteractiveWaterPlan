// Generated by CoffeeScript 1.3.3
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['namespace', 'config/WmsThemeConfig', 'views/BaseStrategyCollectionView', 'views/SourceStrategyView', 'scripts/text!templates/sourceStrategyTable.html'], function(namespace, WmsThemeConfig, BaseStrategyCollectionView, SourceStrategyView, tpl) {
  var SourceStrategyCollectionView;
  return SourceStrategyCollectionView = (function(_super) {

    __extends(SourceStrategyCollectionView, _super);

    function SourceStrategyCollectionView() {
      return SourceStrategyCollectionView.__super__.constructor.apply(this, arguments);
    }

    SourceStrategyCollectionView.prototype.initialize = function(options) {
      var SourceCollection, StrategyCollection, fetchParams;
      _.bindAll(this, 'onFetchBothCollectionSuccess', 'showSourceFeatures', '_registerHighlightEvents', '_registerClickEvents');
      this.sourceId = options.id;
      this.viewName = ko.observable();
      this.mapView = namespace.mapView;
      fetchParams = {
        sourceId: this.sourceId
      };
      StrategyCollection = Backbone.Collection.extend({
        url: "" + BASE_PATH + "api/strategies/source"
      });
      SourceCollection = Backbone.Collection.extend({
        url: "" + BASE_PATH + "api/source/feature/" + this.sourceId
      });
      this.sourceCollection = new SourceCollection();
      SourceStrategyCollectionView.__super__.initialize.call(this, SourceStrategyView, StrategyCollection, tpl, {
        fetchParams: fetchParams
      });
    };

    SourceStrategyCollectionView.prototype.fetchData = function() {
      var params,
        _this = this;
      this.$('tbody').empty();
      params = _.extend({
        year: namespace.currYear
      }, this.fetchParams);
      this.trigger("table:startload");
      $.when(this.strategyCollection.fetch({
        data: params
      }), this.sourceCollection.fetch()).then(this.onFetchBothCollectionSuccess).fail(function() {
        _this.trigger("table:fetcherror");
      });
    };

    SourceStrategyCollectionView.prototype.unrender = function() {
      SourceStrategyCollectionView.__super__.unrender.apply(this, arguments);
      if (this.sourceLayer != null) {
        this.sourceLayer.destroy();
      }
      return null;
    };

    SourceStrategyCollectionView.prototype.onFetchBothCollectionSuccess = function() {
      if (this.onFetchDataSuccess(this.strategyCollection) === false) {
        return;
      }
      this.viewName("Source " + this.sourceId);
      this.showSourceFeatures();
      this.trigger("table:endload");
    };

    SourceStrategyCollectionView.prototype.showSourceFeatures = function() {
      /*
                  #TODO: show the source features. verify can still click on
                  # wugs
                  wktFormat = new OpenLayers.Format.WKT()
      
                  bounds = null
                  sourceFeatures = []
                  lineFeatures = []
                  wugFeature = @wugLayer.features[0]
      
                  for source in @sourceCollection.models
      
                      #skip sources with no geog
                      if not source.get('wktGeog')? then continue
      
                      newFeature = wktFormat.read(source.get('wktGeog'))
                      if not newFeature? then continue
      
                      newFeature.attributes = _.clone(source.attributes)
      
                      #grab the source point for mapping  and transform from geographic to web merc
                      if source.attributes.wktMappingPoint?
                          sourcePoint = wktFormat.read(source.attributes.wktMappingPoint)
                          sourcePoint.geometry = @mapView.transformToWebMerc(sourcePoint.geometry)
      
                          lineFeatures.push new OpenLayers.Feature.Vector(
                              new OpenLayers.Geometry.LineString([sourcePoint.geometry, wugFeature.geometry]),
                              { featureType: "connector" }
                          )
      
                      #we don't need to carry around the large wktGeog
                      delete newFeature.attributes.wktGeog
                      delete newFeature.attributes.wktMappingPoint
                      
                      #transform from geographic to web merc
                      newFeature.geometry = @mapView.transformToWebMerc(
                          newFeature.geometry)
              
                      if not bounds?
                          bounds = newFeature.geometry.getBounds().clone()
                      else
                          bounds.extend(newFeature.geometry.getBounds())
      
                      sourceFeatures.push(newFeature)
      
                  #sort the sourceFeatures so surface water are on top 
                  # of everything else
                  sourceFeatures.sort((a, b) ->
                      
                      if a.attributes.sourceType == "SURFACE WATER" then return 1
                      if b.attributes.sourceType == "SURFACE WATER" then return -1
      
                      return a.attributes.sourceTypeId - b.attributes.sourceTypeId
                  )
                  
                  #create and add the sourceLayer
                  @sourceLayer = new OpenLayers.Layer.Vector(
                      "Source Feature Layer",
                      {
                          displayInLayerSwitcher: false
                          styleMap: this._sourceStyleMap
                      }
                  )
                  @sourceLayer.addFeatures(sourceFeatures)
                  @sourceLayer.addFeatures(lineFeatures) #put the line connector features in with the sources
                  @mapView.map.addLayer(@sourceLayer)
              
                  @mapView.map.setLayerIndex(@wugLayer, 
                      +@mapView.map.getLayerIndex(@sourceLayer)+1)
      
                  
      
                  this._registerHighlightEvents()
                  this._registerClickEvents()
                  
                  #And zoom the map to include the bounds of the sources as well
                  # as the wugFeatures (should only be one)
                  if bounds?
                      wugFeat = @wugLayer.features[0]
                      bounds.extend(wugFeat.geometry.getBounds())
                      @mapView.zoomToExtent(bounds)
      */

    };

    SourceStrategyCollectionView.prototype._registerClickEvents = function() {};

    SourceStrategyCollectionView.prototype._registerHighlightEvents = function() {
      var _this = this;
      this._addLayerToControl(this.highlightFeatureControl, this.sourceLayer);
      this.highlightFeatureControl.events.register('beforefeaturehighlighted', null, function(event) {
        var feature;
        feature = event.feature;
        if ((feature.attributes.featureType != null) && feature.attributes.featureType === "connector") {
          return false;
        }
        return true;
      });
      this.highlightFeatureControl.events.register('featurehighlighted', null, function(event) {
        var popup, sourceFeature;
        if (event.feature.layer.id !== _this.sourceLayer.id) {
          return false;
        }
        sourceFeature = event.feature;
        popup = new OpenLayers.Popup.FramedCloud("sourcepopup", _this.mapView.getMouseLonLat(), null, "                        <b>" + sourceFeature.attributes.name + "</b><br/>                        " + namespace.currYear + " Supply to Water User Group:                         " + ($.number(sourceFeature.attributes.supplyInYear)) + " ac-ft/yr                    ", null, false);
        popup.autoSize = true;
        sourceFeature.popup = popup;
        _this.mapView.map.addPopup(popup);
      });
      this.highlightFeatureControl.events.register('featureunhighlighted', null, function(event) {
        var sourceFeature;
        if (event.feature.layer.id !== _this.sourceLayer.id) {
          return false;
        }
        sourceFeature = event.feature;
        if (sourceFeature.popup != null) {
          _this.mapView.map.removePopup(sourceFeature.popup);
          sourceFeature.popup.destroy();
          sourceFeature.popup = null;
        }
      });
    };

    SourceStrategyCollectionView.prototype._sourceStyleMap = new OpenLayers.StyleMap({
      "default": new OpenLayers.Style({
        strokeColor: "${getStrokeColor}",
        strokeWidth: "${getStrokeWidth}",
        fillColor: "${getFillColor}",
        fillOpacity: 0.8
      }, {
        context: {
          getStrokeColor: function(feature) {
            var style;
            if ((feature.attributes.featureType != null) && feature.attributes.featureType === "connector") {
              return "#ee9900";
            }
            style = _.find(WmsThemeConfig.SourceStyles, function(style) {
              return style.id === feature.attributes.sourceTypeId;
            });
            if (style != null) {
              return style.strokeColor;
            }
            return WmsThemeConfig.SourceStyles[0].strokeColor;
          },
          getStrokeWidth: function(feature) {
            var style;
            style = _.find(WmsThemeConfig.SourceStyles, function(style) {
              return style.id === feature.attributes.sourceTypeId;
            });
            if (style != null) {
              return style.strokeWidth;
            }
            return WmsThemeConfig.SourceStyles[0].strokeWidth;
          },
          getFillColor: function(feature) {
            var style;
            style = _.find(WmsThemeConfig.SourceStyles, function(style) {
              return style.id === feature.attributes.sourceTypeId;
            });
            if (style != null) {
              return style.fillColor;
            }
            return WmsThemeConfig.SourceStyles[0].fillColor;
          }
        }
      }),
      "select": new OpenLayers.Style({
        fillColor: "cyan",
        strokeColor: "blue"
      })
    });

    return SourceStrategyCollectionView;

  })(BaseStrategyCollectionView);
});
